<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<!-- 
	<link href="https://cdn.jsdelivr.net/npm/beercss@3.5.1/dist/cdn/beer.min.css" rel="stylesheet">
	<script type="module" src="https://cdn.jsdelivr.net/npm/beercss@3.5.1/dist/cdn/beer.min.js"></script>
	<script type="module"
		src="https://cdn.jsdelivr.net/npm/material-dynamic-colors@1.1.0/dist/cdn/material-dynamic-colors.min.js"></script>
	-->
	<link rel="stylesheet" href="style.css">
</head>

<body>
	<details data-d="BASI">
		<summary>BASI</summary>
		<article>
			<h1>OGGETTI [<a href="./BASE/oggetti/oggetti_01.html">link</a>]</h1>
			<h2>1. Oggetti Letterali</h2>
			<h2>2. Oggetti Creati da Costruttori</h2>
			<h2>3. Istanze di Classi</h2>
			<h2>4. Oggetti Singleton tramite new Object()</h2>
			<h2>5. Oggetti Function</h2>
			<h2>6. Oggetti Array</h2>
			<h2>7. Oggetti Globali</h2>
			<h2>8. Oggetti Prototipo</h2>
			<h2>9. Oggetti creati con Object.create()</h2>
		</article>
		<article>
			<h1>RegExp</h1>
		</article>
	</details>
	<details data-d="ECMAScript_5">
		<summary>ECMAScript 5 (2009)</summary>
		<article>
			<h1>map() reduce() some() filter()[<a href="./ECMAScript_5/a2009_01/a2009_01.html">link</a>]</h1>
			<p>Sono metodi per Array.</p>

			<p>Per usarli sugli oggetti, devo fare un passaggio intermedio trasformandoli in Array:
			</p>
			<p>
				<b>Object.keys(), Object.values(), o Object.entries()</b> per convertire un oggetto rispettivamente
				nelle sue chiavi, nei suoi valori, o in un array di coppie chiave-valore
			</p>
			<p class="codice">
				const increasedEntries = Object.entries(obj).map(([key, value]) => [key, value + 1]);
				console.log(Object.fromEntries(increasedEntries)); // { a: 2, b: 3, c: 4 }
			</p>


		</article>
	</details>
	<details data-d="ECMAScript2015">
		<summary>ECMAScript2015</summary>
		<article>
			<h1>1. Let e Const</h1>
			<p>Nuove parole chiave per la dichiarazione di variabili, offrendo opzioni con scope a blocco (let) e
				costanti immutabili (const).</p>
		</article>
		<article>
			<h1>2. Classi</h1>
			<p>Sintassi più chiara e semplice per creare classi e gestire l'ereditarietà, avvicinando JavaScript agli
				altri linguaggi di programmazione orientati agli oggetti.
			</p>
		</article>
		<article>
			<h1>3. Moduli [<a href="./ECMAScript2015/a2015_03/a2015_03.html">a2015_03</a>]</h1>
			<p>Supporto nativo per i moduli, permettendo di esportare e importare esplicitamente funzioni, oggetti o
				primitive da un modulo all'altro.
			</p>
		</article>
		<article>
			<h1>4. Template Literal</h1>
			<p>Stringhe che permettono di incorporare espressioni, migliorando la leggibilità del codice quando si
				manipolano stringhe o si creano stringhe multilinea.
			</p>
		</article>
		<article>
			<h1>5. Destructuring Assignment</h1>
			<p>Permette di estrarre dati da array o oggetti in variabili separate tramite una sintassi che riflette la
				costruzione dell'array o dell'oggetto.
			</p>
		</article>
		<article>
			<h1>6. Default, Rest, e Spread Parameters</h1>
			<p>Funzionalità per gestire parametri di funzione in modo più flessibile, inclusa l'assegnazione di valori
				di default, la raccolta di argomenti residui in un array, e l'espansione di un array in singoli
				argomenti.
			</p>
		</article>
		<article>
			<h1>7. Arrow Functions [<a href="./ECMAScript2015/a2015_07/a2015_07.html">a2015_07</a>]</h1>
			<p>Introduce una sintassi più breve per scrivere funzioni, oltre a condividere lo stesso this del contesto
				circostante</p>
		</article>
		<article>
			<h1>8. Promises</h1>
			<p>Supporto nativo per la programmazione asincrona, permettendo di gestire in modo più semplice operazioni
				asincrone.</p>
		</article>
		<article>
			<h1>9. Map e Set</h1>
			<p>Nuove strutture di dati per la gestione di collezioni di valori unici (Set) e coppie chiave-valore (Map).
			</p>
		</article>
		<article>
			<h1>10. Symbol [<a href="./ECMAScript2015/a2015_10/a2015_10.html">link</a>]</h1>
			<p>Un nuovo tipo primitivo che può essere usato come identificatore univoco di proprietà degli oggetti.
			</p>
		</article>
		<article>
			<h1>11. Iterators e For-Of Loop e Symbol.Iterator [<a
					href="./ECMAScript2015/a2015_11/a2015_11.html">link</a>]</h1>
			<p>Introduzione di iteratori, oggetti che consentono di iterare su collezioni, e il ciclo for-of per
				attraversare i valori di qualsiasi oggetto iterabile.</p>
			<p>se vuoi usare un ciclo for...of su un oggetto personalizzato, quel oggetto deve implementare il metodo
				Symbol.iterator. Gli oggetti nativi come Array, String, Map e Set già implementano questo metodo, quindi
				puoi iterarli direttamente con for...of. Ma se crei un oggetto personalizzato e vuoi che sia iterabile
				con for...of, devi definire esplicitamente Symbol.iterator e il metodo next() all'interno di esso.</p>
			<p>
				Il ciclo for...of è stato introdotto per iterare su qualsiasi oggetto iterabile. Gli oggetti iterabili
				includono array, stringhe, mappe, set e qualunque oggetto che implementi il metodo Symbol.iterator
			</p>
			<b>esempio con Array</b>
			<p class="codice">
				let array = [10, 20, 30, 40];
				for (let value of array) {
				console.log(value); // Stampa 10, 20, 30, 40
				}

			</p>
			<b>for...of e Oggetti Non-Array</b>
			<p>Gli oggetti JavaScript standard (cioè gli oggetti literal {}) non sono iterabili con for...of a meno che
				non definiscano esplicitamente un iteratore tramite Symbol.iterator</p>
			<p class="codice"></p>
		</article>
		<article>
			<h1>12. Parametri di funzione migliorati [<a href="/ECMAScript2015/a2015_12/a2015_12.html">link</a>]</h1>
			<p>Include parametri di default, rest parameters e spread operator per gestire gli argomenti delle funzioni
				in modo più efficace.</p>
			<p>
				<b>Parametri di Default</b>
				I parametri di default permettono di assegnare valori predefiniti ai parametri di una funzione, che
				vengono utilizzati qualora non venga passato alcun valore o venga passato undefined.
			</p>
			<p class="codice">
				function saluta(nome = "Visitatore") {
				console.log(`Ciao, ${nome}!`);
				}

				saluta(); // Output: Ciao, Visitatore!
				saluta("Giovanni"); // Output: Ciao, Giovanni!
			</p>
			<p><b>Rest Parameters</b>
				I rest parameters permettono di rappresentare un numero indefinito di argomenti come un array. Ciò è
				utile quando non sai quanti argomenti verranno passati alla tua funzione.</p>
			<p class="codice">
				function somma(...numeri) {
				return numeri.reduce((totale, num) => totale + num, 0);
				}

				console.log(somma(1, 2, 3)); // Output: 6
				console.log(somma(1, 2, 3, 4, 5)); // Output: 15
			</p>

		</article>
		<article>
			<h1>13. Reflect e Proxy [<a href="/ECMAScript2015/a2015_13/index.html">link</a>]</h1>
			<p> Nuove API per la metaprogrammazione, consentendo di intercettare e definire comportamenti personalizzati
				per operazioni fondamentali su oggetti.</p>
			<p class="codice">
				let ob1 = Object.create({name: "Mario"})

				Reflect.defineProperty(ob1, 'nome', {value: 'Giovanni'})
				console.log(Reflect.get(ob1,'nome'))
			</p>
		</article>
		<article>
			<h1></h1>
			<p></p>
			<p class="codice"></p>
		</article>
		<article>
			<h1></h1>
			<p></p>
		</article>
	</details>
	<details data-d="ECMAScript2016">
		<summary>ECMAScript2016</summary>
		<article>
			<h1>1. Array.prototype.includes [<a href="./ECMAScript2016/a2016_01/index.html">a2016_01</a>]</h1>
			<p>Questo metodo consente di determinare se un array include un determinato elemento,
				restituendo true o false a seconda del caso. È una scorciatoia più leggibile rispetto all'utilizzo
				precedente di Array.prototype.indexOf() per verificare la presenza di un elemento in un array.</p>

			<p class="codice">
				const arr = [1, 2, 3];

				console.log(arr.includes(2)); // true
				console.log(arr.includes(4)); // false
			</p>
		</article>
		<article>
			<h1>2. L'operatore di esponenziazione (**) [<a href="./ECMAScript2016/a2016_02/a2016_02.html">a2016_02</a>]
			</h1>
			<p></p>
			<p class="codice">
				console.log(2 ** 3); // 8
				console.log(10 ** -1); //0.1</p>
		</article>
	</details>
	<details data-d="ECMAScript2017">
		<summary>ECMAScript2017</summary>
		<article>
			<h1>1. Async/Await [<a href="./ECMAScript2017/a2017_01/a2017_01.html">a2017_01</a>]</h1>
			<p>codice asincrono più leggibile e simile a codice sincrono tradizionale</p>
			<p class="codice">
				async function fetchData() {
				const data = await fetch('url');
				const json = await data.json();
				console.log(json);
				}

			</p>
		</article>
		<article>
			<h1>2. Object.values() e Object.entries() [<a href="./ECMAScript2017/a2017_02/a2017_02.html">a2017_02</a>]
			</h1>
			<p>Object.values(obj) restituisce un array dei valori delle proprietà enumerabili di un oggetto.
				<br>Object.entries(obj) restituisce un array delle coppie chiave-valore delle proprietà enumerabili
				di un oggetto.
			</p>
			<p class="codice">
				const obj = { a: 1, b: 2, c: 3 };
				console.log(Object.values(obj)); // [1, 2, 3]
				console.log(Object.entries(obj)); // [['a', 1], ['b', 2], ['c', 3]]

			</p>
		</article>
		<article>
			<h1>3. String padding [<a href="./ECMAScript2017/a2017_03/a2017_03.html">a2017_03</a>]</h1>
			<p><b>String.prototype.padStart() e String.prototype.padEnd()</b> permettono di aggiungere padding
				all'inizio o alla fine di una stringa, rispettivamente.</p>
			<p class="codice">
				console.log('ES8'.padStart(4, '0')); // "0ES8"
				console.log('ES8'.padEnd(4, '!')); // "ES8!"
			</p>
		</article>
		<article>
			<h1>4. Object.getOwnPropertyDescriptors() [<a href="./ECMAScript2017/a2017_04/a2017_04.html">a2017_04</a>]
			</h1>
			<p>Restituisce tutti i descrittori di proprietà proprie di un oggetto, inclusi quelli non enumerabili.
			</p>
			<p class="codice">
				const obj = { a: 1 };
				console.log(Object.getOwnPropertyDescriptors(obj));
			</p>
		</article>
	</details>
	<details data-d="ECMAScript2018">
		<summary>ECMAScript2018</summary>
		<article>
			<h1>1. Operator Spread/Rest Properties per gli oggetti [<a href="./VARIE/IIFE/index.html">link</a>]</h1>
			<p>Gli operatori Spread e Rest, precedentemente disponibili solo per gli array, sono stati estesi agli
				oggetti.
				Questo permette una copia più semplice delle proprietà da un oggetto all'altro.</p>
			<b>Spread</b>
			<p class="codice">
				const obj1 = { a: 1, b: 2 };
				const obj2 = { ...obj1, c: 3 }; // { a: 1, b: 2, c: 3 }
			</p>
			<b>Rest Properties</b>
			<p class="codice">
				let { a, ...x } = { a: 1, b: 2, c: 3 };
				console.log(x); // { b: 2, c: 3 }
			</p>
		</article>
		<article>
			<h1>2. Asynchronous Iteration</h1>
			<p>Consente di utilizzare for-await-of per iterare su dati asincroni, ad esempio per leggere da uno stream.
			</p>
			<p class="codice">
				async function asyncIterable() {
				let arr = [1, 2, 3];
				for await (let value of arr) {
				console.log(value);
				}
				}
				asyncIterable();
			</p>
		</article>
		<article>
			<h1>3. Promise.prototype.finally()</h1>
			<p>permette di eseguire del codice alla conclusione di una Promise, indipendentemente dal suo esito (sia
				resolve che reject).</p>
			<p class="codice">
				let promise = Promise.resolve(123);
				promise.then(value => console.log(value))
				.finally(() => console.log("Completed")); // Outputs: 123, Completed
			</p>
		</article>
		<article>
			<h1>4. Template Literals migliorati</h1>
		</article>
		<article>
			<h1>5. RegExp features</h1>
			<p>ECMAScript 2018 ha introdotto diverse nuove funzionalità per le espressioni regolari, come il supporto
				per named capture groups, unicode property escapes, lookahead e lookbehind assertions.</p>
			<b>Named Capture Groups</b>
			<p class="codice">
				let regex = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
							let match = regex.exec("2021-08-23");
							console.log(match.groups.year); // "2021"
			</p>
			<b>Lookbehind Assertion</b>
			<p class="codice">
				let regex = /(?<=\$)\d+ /; console.log("Cost: $100".match(regex)); // ["100"] </p>
					<b>RegExp dotAll flag</b>
					<p>La flag s consente al carattere . nelle espressioni regolari di corrispondere anche ai
						terminatori di linea, che normalmente non farebbe</p>
					<p class="codice">
						let regex = /foo.bar/s;
						console.log(regex.test("foo\nbar")); // true
					</p>
					<b>Unicode Property Escapes in RegExp</b>
					<p>
						Permette di usare le proprietà Unicode nei caratteri delle espressioni regolari.
					</p>
					<p class="codice">
						let regex = /\p{Script=Greek}/u;
						console.log(regex.test('α')); // true
					</p>
		</article>
		<article>
			<h1></h1>
			<p></p>
			<p class="codice"></p>
		</article>

	</details>
	<details data-d="ECMAScript2019">
		<summary>ECMAScript2019</summary>
		<article>
			<h1>1. Array.prototype.flat()</h1>
			<p>Questa funzione appiattisce gli array annidati fino a una profondità specificata. È utile per lavorare
				con array di array.</p>
			<p class="codice">
				const arr = [1, [2, [3, [4]]]];
				console.log(arr.flat()); // Output: [1, 2, [3, [4]]]
				console.log(arr.flat(2)); // Output: [1, 2, 3, [4]]

			</p>
		</article>
	</details>
	<details data-d="ECMAScript2020">
		<summary>ECMAScript2020</summary>
		<article data-d="1. Nullish coaleshing Operaror">
			<h1>1. Nullish coaleshing Operaror [<a href="./ECMAScript2020/a2020_01/a2020_01.html">??link</a>]</h1>
			<p><b>A ?? B</b></p>
			<p>
				La sintassi è <u>A ?? B</u>, che può essere interpretata come:

				Se A è null o undefined, valuta e restituisce B.
				Altrimenti, restituisce A.
			</p>


			<p class="codice">
				let test_1; // Con a = undefined => B
				let test_2 = null; // Con a = null => B

				// i seguenti sono tutti accettati => A
				let test_3 = 0;
				let test_4 = "";
				let test_5 = [3,4];
				let test_6 = [];
				let test_7 = {};
			</p>
		</article>
		<article data-d="2. Optional chainig">
			<h1>2. Optional chainig [<a href="./ECMAScript2020/a2020_02/a2020_02.html">??link</a>]</h1>
			<p><b>valore?.proprietà</b></p>
			<p>Si susa in situazioni di incertezza come risultati da una query. Quando uso gli oggetti (es. ricevo un
				risultato in json) se una chiave non è settata ottengo "undefined" e se cerco una sotto proprietà di una
				undefined ricevo un errore. L'operatore "?." cattura questo errore e restituisce "undefined" </p>
		</article>

	</details>
	<details data-d="ECMAScript2021">
		<summary>ECMAScript2021</summary>
		<article data-d="1. Metodi String: replaceAll">
			<h1>1. Metodi String: replaceAll</h1>
			<p><i>Una nuova funzionalità molto richiesta è il metodo replaceAll per le stringhe. Questo metodo consente
					di sostituire tutte le occorrenze di una sottostringa con un'altra sottostringa, non solo la prima
					occorrenza come fa replace.</i></p>
			<p class="codice">const phrase = "Foo Bar Foo";
				const newPhrase = phrase.replaceAll("Foo", "Bar");
				console.log(newPhrase); // "Bar Bar Bar"
			</p>
		</article>
		<article data-d="2. Promise.any">
			<h1>2. Promise.any</h1>
			<p><i>Promise.any è un metodo che accetta un array di Promises e risolve non appena una delle promesse
					nell'array si risolve. Si differenzia da Promise.race perché ignora i rifiuti finché almeno una
					promessa non viene risolta. Se tutte le promesse sono rifiutate, restituisce un errore
					AggregateError.</i></p>
			<p class="codice">const promise1 = Promise.reject(0);
				const promise2 = new Promise((resolve) => setTimeout(resolve, 100, 'quick'));
				const promise3 = new Promise((resolve) => setTimeout(resolve, 500, 'slow'));

				const promises = [promise1, promise2, promise3];

				Promise.any(promises).then((value) => console.log(value)); // "quick"
			</p>
		</article>
		<article data-d="3. Separatore numerico">
			<h1>3. Separatore numerico</h1>
			<p><i>Il separatore numerico consente di rendere più leggibili i numeri lunghi usando il carattere di
					underscore (_) come separatore delle cifre.</i></p>
			<p class="codice">
				const amount = 1_000_000_000;
				console.log(amount); // 1000000000
			</p>
		</article>
		<article data-d="4. Logical Assignment Operators">
			<h1>4. Logical Assignment Operators</h1>
			<p><i>
					Gli operatori di assegnazione logica combinano gli operatori logici (AND &&, OR ||, e NULLISH ??)
					con l'assegnazione. Questo riduce la necessità di scrivere codice verboso per alcune operazioni
					comuni.
				</i></p>
			<p class="codice">
				let a = 1;
				let b = null;

				a ||= 5;
				console.log(a); // 1

				b &&= 5;
				console.log(b); // null

				let c = null;
				c ??= 5;
				console.log(c); // 5

			</p>
		</article>
		<article data-d="5. WeakRef e FinalizationRegistry">
			<h1>5. WeakRef e FinalizationRegistry</h1>
			<p><i>WeakRef consente di tenere un riferimento debole a un oggetto, che non impedisce al garbage collector
					di cancellare l'oggetto, mentre FinalizationRegistry fornisce un modo per eseguire callback quando
					gli oggetti sono garbage-collected.</i></p>
		</article>
	</details>
	<details data-d="ECMAScript2022">
		<summary>ECMAScript2022</summary>
		<article data-d="1. Class Fields (Campi delle classi)">
			<h1>1. Class Fields (Campi delle classi)</h1>
		</article>
		<article data-d="2. Top Level await">
			<h1>2. Top Level await</h1>
			<p><i>Il top level await permette l'uso di await al di fuori di una funzione async all'interno dei moduli
					JavaScript. Questo rende il codice asincrono più facile da scrivere e da leggere, soprattutto quando
					si lavora con moduli che dipendono da risorse asincrone.</i></p>
			<p class="codice">// In un modulo JS, puoi ora fare:
				const dynamicData = await fetch('https://api.example.com/data');
				console.log(dynamicData.json());
			</p>
		</article>
		<article data-d="3. Ergonomic Brand Checks for Private Fields">
			<h1>3. Ergonomic Brand Checks for Private Fields</h1>
			<p><i>Questa aggiunta consente di controllare più ergonomicamente se un oggetto ha un determinato campo
					privato, utilizzando una nuova sintassi che genera un errore in caso di assenza, invece di
					restituire semplicemente false</i></p>
		</article>
		<article data-d="4. .at() Method for Arrays and Typed Arrays">
			<h1>4. .at() Method for Arrays and Typed Arrays</h1>
			<p><i>Il metodo .at() è stato aggiunto per semplificare l'accesso agli elementi di un array, permettendo un
					accesso più facile agli elementi dall'inizio o dalla fine dell'array usando un indice positivo o
					negativo.</i></p>
			<p class="codice">
				const array = [10, 20, 30, 40, 50];
				console.log(array.at(-1)); // 50
				console.log(array.at(0)); // 10
			</p>
		</article>
		<article data-d="5. Object.hasOwn()">
			<h1>5. Object.hasOwn()</h1>
			<p><i>Questa è una nuova funzione statica aggiunta a Object per verificare se un oggetto possiede una
					proprietà come propria (non ereditata). È un'alternativa a Object.prototype.hasOwnProperty() che
					evita alcuni dei problemi legati all'ereditarietà di hasOwnProperty.</i></p>
			<p class="codice">
				const obj = { a: 1 };
				console.log(Object.hasOwn(obj, 'a')); // true
				console.log(Object.hasOwn(obj, 'toString')); // false

			</p>
		</article>
		<article data-d="6. Formatting API for Intl: Intl.ListFormat">
			<h1>6. Formatting API for Intl: Intl.ListFormat</h1>
			<p><i>La nuova API Intl.ListFormat permette di formattare liste di elementi secondo le convenzioni locali,
					che è utile per la localizzazione delle applicazioni.</i></p>
			<p class="codice">
				const formatter = new Intl.ListFormat('en', { style: 'long', type: 'conjunction' });
				console.log(formatter.format(['Alice', 'Bob', 'Charlie'])); 
				// Alice, Bob, and Charlie
			</p>
		</article>
	</details>
	<details data-d="VARIE">
		<summary>VARIE</summary>
		<article>
			<h1>1. IIFE (Immediately Invoked Function Expression) [<a href="./VARIE/IIFE/index.html">link</a>]</h1>
			<p>Invoca immediatamente il codie contenuto nella prima coppia di parentesi (...)();
				Posso passare parametri inserendoli nella seconda coppia di parentesi ()(...);
				Le funzioni definite nelle IIFE non sono riutilizzabili al di fuori della IIFE.
				Serve ad evitare conflitti di nomi.
			</p>

		</article>
		<article>
			<h1>setInterval [<a href="./VARIE/setInterval/index.html">link</a>]</h1>
			<p> ha 2 parametri: 1. funzione 2. intervallo di tempo in ms</p>

		</article>
		<article>
			<h1>3. Factory Function e Fx che restituiscono oggetti [<a href="./VARIE/Funzioni/index.html">link</a>]
			</h1>
			<p><b>Factory Function</b> usata per creare più istanze. Non usa il new ma crea ugualmente l'oggetto
				this</p>
			<p><b>Function che restituiscono oggetti</b> usate per personalizzare un singolo oggetto</p>

		</article>
		<article>
			<h1>4. Computed property names degli Oggetti</h1>
			<p>Permette di utilizzare un valore variabile o calcolato come nome della proprietà o del metodo</p>
			<p class="codice">
				let propName = "dynamicName";
				let obj = {
				[propName]: "value1"
				};
				console.log(obj.dynamicName); // Outputs: value1
			</p>
		</article>
		<article>
			<h1>5. Scroll [<a href="./VARIE/scroll/scroll.html">link</a>]</h1>
			<p>In js lo scroll è un evento della finestra che si può gestire</p>
		</article>
		<article>
			<h1>6. Json [<a href="./VARIE/json/json.html">link</a>]</h1>
			<p>Come si fa il parsing da formato Json (=stringa) a formato JS (=oggetto)</p>
			<p class="codice">
				//da stringa Json a oggetto Js
				const persone = JSON.parse(data);

				//da oggetto Js a stringa Json (per poterlo inviare al back-end)
				const stringaJson = JSON.stringify(persone);

				//da stringa Json a oggetto Js
				fetch('./data.json')
				.then(response => response.json())
				.then(info => console.log(info))
			</p>
			<p>posso poi mandare a schermo creando un elemento html</p>
			<p class="codice">
				const divElement = document.createElement("div")
			</p>
			<p>inserendo il testo e inserendolo nel body</p>
			<p class="codice">
				divElement.innerHTML = ...
				document.body.appendChild(divElement);
			</p>
			<h2> Ricorda l' Optional chaining quando ricevi dati, soprattutto non sql</h2>
			<p class="codice">
				${element.figli?.join(', ')} mosta a schermo undefined: poich' la proprietà è undefined js non applica
				.join(', ') che andrebbe in errore.
				a questo punto gestisco undefined:
				${element.figli?.join(', ') ?? "Nessun figlio"}
				versione breve per:
				${element.figli ? 'figli:'+element.figli.join(', ') : 'Nessun figlio'}</p>`;
			</p>
		</article>
		<article>
			<h1>7. Errori [<a href="./VARIE/gestione_errori/errori.html">link</a>]</h1>
			<h2>Gestione errori</h2>
			<p><b>try{ ... } catch(error){ }</b> evita che un errore blocchi l'esecuzione</p>
			<p><b>try{ ... } catch(error) { ... }</b> evita che un errore blocchi l'esecuzione e gestisco l'errore</p>
			<p><b>try{ ... } catch(error) { ... } finally { ... }</b> esegue del codice al termine, anche se c'è stato
				un errore</p>
			<h2>Generazione di un errore</h2>
			<p><b>if( ... ){throw new Error('Testo...')}</b> se si verifica una condizione sollevo volontariamente un
				avviso di errore</p>
			<p>un caso può essere durante la validazione:
				<b>parseInt ... if(isNan){throw new Error('Testo...')}</b>
			</p>

		</article>
		<article>
			<h1>8. Custom event [<a href="./VARIE/customevent/event.html">link</a>]</h1>
			<p>creo l'evento</p>
			<p>creo il listener con all'interno la callback</p>
			<p>creo il dispatch (attivatore)</p>
			<p>Caso più comune di uso: svolgo un task e alla conclusione dispaccio un evento, i listener interessati si
				attivano</p>
		</article>
		<article>
			<h1>9. localStorage [<a href="./VARIE/localStorage/localStorage.html">link</a>]</h1>

			<p>Salva in locale fino a 5mb in formato stringa. Quindi prima di salvare qualcosa che non sia una stringa
				dobbiamo usare <b>JSON.stringify( ... )</b> e poi <b>JSON.parse( ... )</b>
				Viene usato per salvare in locale le preferenze utente e altre informazioni che non voglioamo ospitare
				su server. Non devono contenere dati sensibili poichè sono visibili dall'utente tramitte il tasto "F12"
			<ul>
				<li>localStorage.<b>setItem</b>('isTemaScuro',true)</li>
				<li>const info = localStorage.<b>getItem</b>('isTemaScuro');</li>
			</ul>
			</p>
			<p>
			<ul>
				<li>localStorage.<b>setItem</b>('preferenze', JSON.stringify(preferenze))</li>
				<li>const info = JSON.parse(localStorage.<b>getItem</b>('preferenze'));</li>
			</ul>
			</p>
			<p>
			<ul>
				<li>localStorage.<b>removeItem</b>('preferenze');</li>
			</ul>
			</p>

		</article>
		<article> 10. Drag and Drop
			<h1> [<a href="./VARIE/dragDrop/dragDrop.html">link</a>]</h1>
			<p>gli eventi coinvolti nel drag and drop:
				<b>oggetto draggable="true"</b>
			<ul>
				<li>dragstart</li>
				<li>drag</li>
				<li>gragend</li>
			</ul>
			<b>area contenitore</b>
			<li>dragenter</li>
			<li>dragover</li>
			<li>dragleave</li>
			<li>drop</li>
			</p>
			<p class="codice">
				const mela = document.getElementById('mela');
				const cestino = document.getElementById('cestino');

				mela.addEventListener('dragstart', handleDragStart);
				mela.addEventListener('dragend', handleDragEnd);

				function handleDragStart() {
				console.log('Drag Start')
				mela.style.opacity=1;
				}

				function handleDragEnd() {
				console.log('Drag End')
				mela.style.backgroundColor="grey";
				}
			</p>
		</article>

	</details>
	<!-- 
			<article data-d="">
				<h1></h1>
				<p><i></i></p>
				<p class="codice"></p>
			</article>
			<article data-d="">
				<h1> [<a href="./ECMAScript2015/a2015_13/index.html">link</a>]</h1>
				<p></p>
				<p class="codice"></p>
			</article>
		
			<details>
				<summary></summary>
				<article data-d="">
					<h1></h1>
					<p></p>
					<p class="codice"></p>
				</article>
			</details>

	-->
</body>
<style>
</style>

</html>